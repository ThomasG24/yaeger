<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Yaeger</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="A Java based 2D Game Engine, focused on an Object Oriented style of programming">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Yaeger</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/han-yaeger/yaeger" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="yaeger_"><a class="header" href="#yaeger_">YAEGER_</a></h1>
<p>Yaeger is Another Education Game Engine Runtime, and a fully functional 2D
game-engine that requires only a traditional Object-Oriented style of
programming. To create a game, classes should be extended and interfaces
should be implemented.</p>
<p>Its API is based on inheritance and composition and can be seen as a layer of
abstraction on top of JavaFX. JavaFX is only exposed minimally, so it is not
trivially possible to use JavaFX within Yaeger. This is by design.</p>
<h2 id="required-java-version"><a class="header" href="#required-java-version">Required Java version</a></h2>
<p>Although Yaeger only exposes a traditional Object-Oriented API, internally its
based on modern Java. To see which specific version is required, please read
the <a href="https://github.com/han-yaeger/yaeger">readme</a> on the project GitHub.</p>
<h2 id="howto-read-this-manual"><a class="header" href="#howto-read-this-manual">Howto read this manual</a></h2>
<p>This manual is only meant to give a high-level overview. It will paint a
picture of how a game can be created and what kind of objects are available.
The details and specifics will not be part of this manual. They can be found in
the <a href="https://han-yaeger.github.io/yaeger/">JavaDoc API</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-game"><a class="header" href="#creating-a-game">Creating a game</a></h1>
<p>To create a new Yaeger Game, a Java class should be created that</p>
<ul>
<li>extends <code>YeagerGame</code></li>
<li>contains the following method:</li>
</ul>
<pre><code class="language-java">public static void main(String[]args){
    launch(args);
}
</code></pre>
<p>Such a game does not have any content yet, but it can be run and will only
show the Splash screen. This Splash screen  will be shown before each Yaeger
Game. It can, however, be disabled by adding a commandline argument when running
your game. More information on this can be found
<a href="commandline-arguments.html">here</a>.</p>
<h2 id="lifecycle-methods-of-yeagergame"><a class="header" href="#lifecycle-methods-of-yeagergame">Lifecycle methods of <code>YeagerGame</code></a></h2>
<p>By extending <code>YeagerGame</code>, several methods will need to be implemented.
These methods are part of the lifecycle of a Yaeger Game and will be responsible
for setting up the content of the Game.</p>
<h3 id="setting-up-the-game-through-setupgame"><a class="header" href="#setting-up-the-game-through-setupgame">Setting up the game, through <code>setupGame()</code></a></h3>
<p>The first method to implement is <code>setupGame()</code>, which has the following s
ignature:</p>
<pre><code class="language-java">@Override
protected void setupGame(){
}
</code></pre>
<p>This method will be called first and must be used to set up the width/height
and title of the Game. A typical implementation can look like:</p>
<pre><code class="language-java">@Override
protected void setupGame(){
    setGameTitle("Waterworld");
    setSize(new Size(800,600));
}
</code></pre>
<p>For more information, check the
<a href="https://han-yaeger.github.io/yaeger/hanyaeger/com/github/hanyaeger/api/YaegerGame.html#setupGame()">API</a>
of <code>setupGame()</code></p>
<h3 id="adding-scenes-through-setupscenes"><a class="header" href="#adding-scenes-through-setupscenes">Adding Scenes, through <code>setupScenes()</code></a></h3>
<p>After <code>setupGame()</code> has been called, Yaeger will call <code>setupScenes()</code>. This is
the second step in the life cycle of a Yaeger Game, in which it expects the
developer to add Scenes to the Game. Scenes can be added by calling
<code>addScene(int, YaegerScene)</code>. The first parameter is the <code>id</code> of the
<code>YaegerScene</code>, which can be used to select which <code>YaegerScene</code> will be shown.
By default, the first scene that is added, will be the first scene that is
shown.</p>
<p>A typical implementation can ook like:</p>
<pre><code class="language-java">@Override
protected void setupScenes(){
    addScene(0, new TitleScene(this));
    addScene(1, new GameLevel(this));
    addScene(2, new GameOverScene(this));
}
</code></pre>
<h2 id="loading-a-scene"><a class="header" href="#loading-a-scene">Loading a scene</a></h2>
<p>When adding scenes to the Yaeger Game, the first added scene will also be the
one that gets loaded and becomes visible. To load a specific scene,
<code>YaegerGame</code> provides the method <code>setActiveScene(int)</code>. Read
the <a href="https://han-yaeger.github.io/yaeger/hanyaeger/com/github/hanyaeger/api/YaegerGame.html#setActiveScene(int)">API</a>
for the details on how to use this method.</p>
<h2 id="what-about-the-constructor"><a class="header" href="#what-about-the-constructor">What about the constructor?</a></h2>
<p>For Plain Old Java Objects (POJO's) the constructor is usually used for
configuring your Object. Although it is not always the best approach, since
the constructor should be only used for <strong>constructing</strong> an Object, not for
<strong>configuring</strong> it, it will usually still work.</p>
<p>With Yaeger, however, it will usually <em>not</em> work. Configuring a <code>YaegerGame</code>
should only be done from the <code>setupGame()</code> method. Furthermore, the
constructor of the class that extends <code>YaegerGame</code> should be empty, since Yaeger
will otherwise not know how to make an instance of it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scenes-aka-levels"><a class="header" href="#scenes-aka-levels">Scenes aka levels</a></h1>
<p>After scenes have been added, Yaeger will load the first one. In this chapter we
will dive deeper into them.</p>
<h2 id="what-are-scenes"><a class="header" href="#what-are-scenes">What are scenes?</a></h2>
<p>A game is usually comprised of different 'parts', such as levels, menu's or a
game-over screen. Some of those are just simple images and other are complex
levels, with lots of behaviour.</p>
<p>In Yaeger, all of them implement <code>YaegerScene</code> and will be referred to as a
Yaeger scene. For a simple Yaeger scene, without any moving parts, Yaeger
provides the abstract class <code>StaticScene</code>. In case of a complex scene, with
moving parts and a so-called Game World Update, Yaeger provides a
<code>DynamicScene</code>. Both can be added to Yaeger, since they both implement
<code>YaegerScene</code>. Their behaviour is, however, quite different.</p>
<h3 id="staticscene"><a class="header" href="#staticscene"><code>StaticScene</code></a></h3>
<p>A <code>StaticScene</code> is a scene that is not aware of time. It can contain anything
you like, and those things will listen to user interaction, but their behaviour
will not be based on the concept of time. Typical use cases are:</p>
<ul>
<li>A Menu</li>
<li>A Game Over scene</li>
<li>An inventory selection scene</li>
</ul>
<h3 id="dynamicscene"><a class="header" href="#dynamicscene"><code>DynamicScene</code></a></h3>
<p>A <code>DynamicScene</code> is exactly the same as a <code>StaticScene</code>, but it is also aware of
time. A <code>DynamicScene</code> contains a Game World Update, that calls a
<code>update(long)</code> method on the scene itself and all dynamic parts of the scene.
This way, it is possible to create movement and add time-based behaviour.
Typical use cases are:</p>
<ul>
<li>A level for a game</li>
<li>A Splash screen</li>
<li>A scene with any form of finiteAnimation</li>
</ul>
<h3 id="scrollabledynamicscene"><a class="header" href="#scrollabledynamicscene"><code>ScrollableDynamicScene</code></a></h3>
<p>A <code>ScrollableDynamicScene</code> is exactly the same as a <code>DynamicScene</code>, but allows a
different width/height for its content. This way the scene can be much larger
that the viewable area (the viewport). The width and height of the scene can be
set from the <code>setupScene()</code> and the part of the scene that is visible can be set
by setting the scroll-position.</p>
<h2 id="creating-a-scene"><a class="header" href="#creating-a-scene">Creating a scene</a></h2>
<p>To create either a <code>StaticScene</code> or <code>DynamicScene</code>, let your own scene extend
one of those. As when extending <code>YaegerGame</code>, again two methods will need to be
implemented:</p>
<ul>
<li><code>setupScene()</code>, which should be used for setting all the properties of the
scene</li>
<li><code>setupEntities()</code>, which should be used for adding various entities (Game
Objects) to the Scene</li>
</ul>
<h3 id="setting-up-the-scene-through-setupscene"><a class="header" href="#setting-up-the-scene-through-setupscene">Setting up the scene, through <code>setupScene()</code></a></h3>
<p>The first method to implement is <code>setupScene()</code>, which has the following
signature:</p>
<pre><code class="language-java">@Override
protected void setupScene(){
        }
</code></pre>
<p>This method will be called first and must be used to set up the background
image, background color and background audio of the scene.</p>
<p>A typical implementation can look like:</p>
<pre><code class="language-java">@Override
public void setupScene(){
        setBackgroundAudio("audio/ocean.mp3");
        setBackgroundImage("backgrounds/background1.jpg");
        }
</code></pre>
<p>For more information, check the
<a href="https://han-yaeger.github.io/yaeger/hanyaeger/com/github/hanyaeger/api/scenes/YaegerScene.html#setupScene()">API</a></p>
<h3 id="adding-entities-to-the-scene-through-setupentities"><a class="header" href="#adding-entities-to-the-scene-through-setupentities">Adding entities to the scene, through <code>setupEntities()</code></a></h3>
<p>After <code>setupScene()</code> has been called, Yaeger will call <code>setupEntities()</code>. This
is the second step in the life cycle of a <code>YaegerScene</code>, in which it expects the
developer to add entities to the scene.</p>
<p>Entities can be added by calling <code>addEntity(YaegerEntity)</code>. Since entities can
overlap, their placement will follow the order in which they are added to the
scene. So newly added entities may overlap entities that had been placed
earlier.</p>
<p>More on entities in the following chapter of this documentation.</p>
<p>A typical implementation can look like:</p>
<pre><code class="language-java">@Override
public void setupEntities(){
        addEntity(new Hanny(new Coordinate2D(1,1),waterworld));
        addEntity(new Swordfish(new Coordinate2D(200,300)));
        addEntity(new Sharky(new Coordinate2D(0,100)));
        }
</code></pre>
<h2 id="what-about-the-constructor-1"><a class="header" href="#what-about-the-constructor-1">What about the constructor?</a></h2>
<p>The same rules apply to a <code>YaegerScene</code>, as do to a <code>YaegerGame</code>. Configuring
the scene should only be done from the <code>setupScene()</code> method.</p>
<p>It is however possible to use the constructor for basic wiring of objects or
other commons object-oriented practices.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entities-aka-game-objects"><a class="header" href="#entities-aka-game-objects">Entities aka Game Objects</a></h1>
<p>Entities are what actually make a game. Anything that can be placed on a scene
will be an Entity and will have to (indirectly) implement the abstract
superclass <code>YaegerEntity</code>.</p>
<h2 id="static-or-dynamic-entities"><a class="header" href="#static-or-dynamic-entities">Static or dynamic entities</a></h2>
<p>Just as with scenes, entities are available in static and dynamic version. The
main difference is that a dynamic entity receives a GWU, where a
static entity does not.</p>
<p>In general static entities will be typically used for menu-items or non-moving
things. Dynamic entities are typically used for anything that should move
around the scene, or should have time-based behaviour in general.</p>
<p>Note that the GWU originates at the scene. To make a dynamic entity to receive
the GWU, it must be added to a dynamic scene. If added to a static scene, it
will be as static as a static entity.</p>
<h2 id="properties-for-all-entities"><a class="header" href="#properties-for-all-entities">Properties for all entities</a></h2>
<p>Although there a different entities, they all share a basic set of properties.
These include the <em>hue</em>, <em>saturation</em>, <em>brightness</em>, <em>rotation</em> and many more.
One of the more interesting properties is the <em>viewOrder</em>, which can be used
to influence the order in which the entities are rendered on the scene. The
lower the value, the closer the entity is placed to the front of the scene.</p>
<h2 id="movement-of-dynamic-entities"><a class="header" href="#movement-of-dynamic-entities">Movement of dynamic entities</a></h2>
<p>Dynamic entities can move around the scene, by setting their motion. This
movement is applied each GWU, which means the entity moves discretely across the
scene (as opposed to continuously).</p>
<p>The motion consists of a <code>direction</code> and <code>speed</code>, which can be set
individually or together. The <code>direction</code> is a double, where the value 0
denotes downward and 180 logically means upward.</p>
<h2 id="different-types-of-entities"><a class="header" href="#different-types-of-entities">Different types of entities</a></h2>
<p>There are several Entities available, which can be divided into four different
types:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Static Entity</th><th style="text-align: left">Dynamic Entity</th><th style="text-align: left">Type</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>SpriteEntity</code></td><td style="text-align: left"><code>DynamicSpriteEntity</code></td><td style="text-align: left">Sprite entity</td></tr>
<tr><td style="text-align: left"><code>CircleEntity</code></td><td style="text-align: left"><code>DynamicCircleEntity</code></td><td style="text-align: left">Shape entity</td></tr>
<tr><td style="text-align: left"><code>EllipseEntity</code></td><td style="text-align: left"><code>DynamicEllipseEntity</code></td><td style="text-align: left">Shape entity</td></tr>
<tr><td style="text-align: left"><code>RectangleEntity</code></td><td style="text-align: left"><code>DynamicRectangleEntity</code></td><td style="text-align: left">Shape entity</td></tr>
<tr><td style="text-align: left"><code>TextEntity</code></td><td style="text-align: left"><code>DynamicTextEntity</code></td><td style="text-align: left">Text entity</td></tr>
<tr><td style="text-align: left"><code>CompositeEntity</code></td><td style="text-align: left"><code>DynamicCompositeEntity</code></td><td style="text-align: left">Composite entity</td></tr>
</tbody></table>
</div>
<p>The sprite, shape and text-entity are basic entities. The composite entity
is of a different type. It should be used whenever the entity should
actually consist of several smaller entities.</p>
<h2 id="applying-physics"><a class="header" href="#applying-physics">Applying physics</a></h2>
<p>Yaeger supports a basic form of physics for entities, through the
<code>Newtonian</code> interface. Since this form of physics is based on motion,
the interface makes only sense when applied to a dynamic entity.</p>
<h2 id="animating-entities"><a class="header" href="#animating-entities">Animating entities</a></h2>
<p>Both the <code>SpriteEntity</code> and the <code>DynamicSpriteEntity</code> can be used to create
animated entities. Fot this, the provides image should be a spritesheet, as
can be seen in the image below:</p>
<p><img src="images/witch-spritesheet.png" alt="A spritesheet" /></p>
<p>For complex animation, an <code>Animation</code> can be created to encapsulate a part
of the spritesheet. For more information, please read the API of the interface
<code>Animation</code> and its implementations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-entities"><a class="header" href="#creating-entities">Creating entities</a></h1>
<p>All available entities, except the <code>TextEntity</code>, are abstract classes, meaning
they should be extended to create an instance. After creating a class, an
instance should be created, which can then be added to a <code>YaegerScene</code>, or a
<code>CompositeEntity</code> through the <code>addEntity(YaegerEntity)</code> method.</p>
<p>In general, the <code>setupEntities()</code> is the appropriate place to do such a
thing, but it is possible to call <code>addEntity(YaegerEntity)</code> from methods such
as <code>setupTimers()</code> (see <a href="timing-things.html">Timing things</a>) or <code>setupSpawners()</code>
(see below).</p>
<h2 id="spawning-entities-at-a-regular-time-interval"><a class="header" href="#spawning-entities-at-a-regular-time-interval">Spawning entities at a regular time-interval</a></h2>
<p>Sometimes many entities should spawn within a scene. For instance, when enemies
spawn to life, or when it snows.</p>
<p>For such cases, Yaeger provides an <code>EntitySpawner</code>, which was designed for
specifically this case.</p>
<h2 id="creating-many-entities-at-once-using-a-tilemap"><a class="header" href="#creating-many-entities-at-once-using-a-tilemap">Creating many entities at once, using a <code>TileMap</code></a></h2>
<p>When many entities populate the scene, a <code>TileMap</code> can be used to easily
create them and to let Yaeger calculate the exact location where they should
be placed.</p>
<p>Imagine the image below should be used multiple times on the scene:</p>
<p><img src="images/tile.png" alt="A tile" />,</p>
<p>and should be placed in such a way that we get the following scene:</p>
<p><img src="images/tile-scene.png" alt="A scene with tiles" />.</p>
<p>A <code>TileMap</code> facilitates this, by defining a two-dimensional array that
represents the scene and stating which entities should be used. The
<code>TileMap</code> will then calculate the location and size of each entity,
instantiate them and add them to the scene.</p>
<p>To be able to use a <code>TileMap</code>, the scene should implement the interface
<code>TileMapContainer</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity-collisions"><a class="header" href="#entity-collisions">Entity collisions</a></h1>
<p>Entities can interact with each other by using collision detection.
Collision detection is Yaeger is fairly simple. Each GWU checks if all
entities that implement <code>Collider</code> intersect with each entity that implements
<code>Collided</code>. If an intersection occurs, the method <code>onCollision (List&lt;Collider&gt;)</code> is called on the entity that implements <code>Collided</code>.</p>
<p>Because collision detection is performed on each GWU, which has a discreet
value of 60 times/second, if entities move at a high speed, it is possible that
collision detection misses their collision. This is currently a limitation
of Yaeger.</p>
<h2 id="entities-leaving-the-scene"><a class="header" href="#entities-leaving-the-scene">Entities leaving the scene</a></h2>
<p>Do be notified whenever an entity leaves the scene border, two interfaces
are available:</p>
<ul>
<li><code>SceneBorderCrossingWatcher</code></li>
<li><code>SceneBorderTouchingWatcher</code></li>
</ul>
<p>Their event handler will be called whenever an entity respectively leaves
the scene border or merely touches the scene border. As with collision
detection, also this checks is performed only on the GWU, meaning it will
not be extremely accurate with fast moving entities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-input"><a class="header" href="#user-input">User Input</a></h1>
<p>A Player can interact with both Entities and Scenes by using the keyboard or
mouse. To enable this interaction the Scene or Entity should implement the
appropriate interface, after which an event handler should be implemented.</p>
<h2 id="available-interactions"><a class="header" href="#available-interactions">Available interactions</a></h2>
<p>The table below gives the full list of interfaces that are available. They can
be found in package
<code>com.github.hanyaeger.api.userinput</code> and most can be applied to all children of
both <code>YaegerEntity</code>
and <code>YaegerScene</code>, only the <code>MouseDraggedListener</code> can only be applied to
children of <code>YaegerEntity</code>.</p>
<p>In case of a <code>ScrollableDynamicScene</code>, the instances of <code>Coordinate2D</code> that are
passed to the event handlers report the coordinates of the entire scene, not
only the viewport.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Interface</th><th style="text-align: left">EventHandler(s)</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>KeyListener</code></td><td style="text-align: left"><code>void onPressedKeysChange(Set&lt;KeyCode&gt;)</code></td></tr>
<tr><td style="text-align: left"><code>MouseButtonPressedListener</code></td><td style="text-align: left"><code>void onMouseButtonPressed(MouseButton, Coordinate2D)</code></td></tr>
<tr><td style="text-align: left"><code>MouseButtonReleasedListener</code></td><td style="text-align: left"><code>void onMouseButtonReleased(MouseButton, Coordinate2D)</code></td></tr>
<tr><td style="text-align: left"><code>MouseEnterListener</code></td><td style="text-align: left"><code>void onMouseEntered()</code></td></tr>
<tr><td style="text-align: left"><code>MouseExitListener</code></td><td style="text-align: left"><code>void onMouseExited()</code></td></tr>
<tr><td style="text-align: left"><code>MouseMovedListener</code></td><td style="text-align: left"><code>void onMouseMoved(Coordinate2D)</code></td></tr>
<tr><td style="text-align: left"><code>MouseMovedWhileDraggingListener</code></td><td style="text-align: left"><code>void onMouseMovedWhileDragging(Coordinate2D)</code></td></tr>
<tr><td style="text-align: left"><code>MouseDraggedListener</code></td><td style="text-align: left"><code>void onMouseDragged(Coordinate2D)</code>, <code>void onDropped(Coordinate2D)</code></td></tr>
<tr><td style="text-align: left"><code>MouseDragEnterListener</code></td><td style="text-align: left"><code>void onDragEntered(Coordinate2D, MouseDraggedListener)</code></td></tr>
<tr><td style="text-align: left"><code>MouseDragExitListener</code></td><td style="text-align: left"><code>void onDragExited(Coordinate2D, MouseDraggedListener)</code></td></tr>
<tr><td style="text-align: left"><code>MouseDropListener</code></td><td style="text-align: left"><code>void onDrop(Coordinate2D, MouseDraggedListener)</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="sounds"><a class="header" href="#sounds">Sounds</a></h1>
<p>Sound are usually an important part of any game. A sound can be either an
effect that is part of the game, or an audio-fragment that is being played at
the background. Both cases are supported by Yaeger, but both require a different
way to make them happen.</p>
<h2 id="background-audio"><a class="header" href="#background-audio">Background audio</a></h2>
<p>Background audio can be set on either the <code>YaegerGame</code> or <code>YaegerScene</code>. In
both cases the audio will loop indefinitely until respectively the <code>YaegerGame</code>
has ended or a different <code>YaegerScene</code> is loaded. This way it is possible to
set background that will be used throughout the game, or is specific to a
<code>YaegerScene</code>.</p>
<h2 id="sound-effects"><a class="header" href="#sound-effects">Sound effects</a></h2>
<p>When a sound effect should be played, a <code>SoundClip</code> can be used. It will only
be played once and as soon as it has finished it becomes eligible for garbage
collection. Although the volume of a <code>SoundClip</code> can be set, note that it is
only applied to the next time it is played. Thus, the volume has to be set
before <code>play()</code> is called.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timing-things"><a class="header" href="#timing-things">Timing things</a></h1>
<p>As can be read in <a href="scenes.html">Scenes aka Levels</a>, there are two different
implementations of <code>YaegerScene</code> available: a <code>StaticScene</code> and a
<code>DynamicScene</code>. Their main difference resides in the fact that a <code>DynamicScene</code>
contains a Game World Update (GWU) to which all instances of <code>DynamicEntity</code>
added to the scene will listen.</p>
<p>This chapter will discuss the different ways in which the GWU can be used within
Yaeger. It will start by discussing how the GWU gets delegated to all
objects, after which different ways are discussed to use it within your scene or
entity.</p>
<h2 id="how-the-gwu-is-delegated-to-all-objects"><a class="header" href="#how-the-gwu-is-delegated-to-all-objects">How the GWU is delegated to all objects</a></h2>
<p>The GWU is initiated by the <code>DynamicScene</code>, and handed down to all dynamic
entities, timers, spawners and composite entities that were added to the scene.
This is done in the same order as in which they were added to the scene.</p>
<p>From a programming point-of-view, the GWU is a timed method call. The
<code>DynamicScene</code> calls its <code>update()</code> method, which then calls all the <code>update()</code>
methods of all the dynamic entities, timers, spawners and composite entities. If
those objects themself also contain child-objects, their <code>update()</code> method is
then also called. And so forth.</p>
<p><img src="images/update-delegation.png" alt="Update Delegation" /></p>
<h3 id="pausing-and-resuming-the-gwu"><a class="header" href="#pausing-and-resuming-the-gwu">Pausing and resuming the GWU</a></h3>
<p>Since the GWU gets initiated at the level of the <code>DynamicScene</code>, and then
passed down, it is possible to pause all objects that are called by this
GWU. For this a <code>DynamicScene</code> provides a method to pause and resume the GWU.</p>
<h2 id="using-a-timer-to-create-time-based-events"><a class="header" href="#using-a-timer-to-create-time-based-events">Using a <code>Timer</code> to create time-based events</a></h2>
<p>On both dynamic scenes and dynamic entities one or more timers can be used
to create time based events. To use such a <code>Timer</code> the scene or entity
should implement the interface <code>TimerContainer</code>. After doing so, the method
<code>setupTimers()</code> should be implemented and the method <code>addTimer(Timer)</code> can
be called to add an instance of <code>Timer</code>.</p>
<h2 id="exposing-the-gwu-to-scenes-and-entities"><a class="header" href="#exposing-the-gwu-to-scenes-and-entities">Exposing the GWU to scenes and entities</a></h2>
<p>The GWU is kept internal on all entities and scenes and gets delegated
downwards. It is, however, possible to expose the GWU to an entity or scene by
implementing the interface <code>UpdateExposer</code>, which exposes an <code>explicitUpdate (long)</code> method. The value passed to this method represents a timestamp
of the current time and can be used to keep track of time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-arguments"><a class="header" href="#command-line-arguments">Command Line Arguments</a></h1>
<p>When run, Yaeger accepts command line arguments. These arguments are primarily
meant for debugging your Game.</p>
<p>The following arguments are currently supported:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Argument</th><th style="text-align: left">Explanation</th></tr></thead><tbody>
<tr><td style="text-align: left">--noSplash</td><td style="text-align: left">Skip the Splash screen during start up.</td></tr>
<tr><td style="text-align: left">--showBB</td><td style="text-align: left">Show the BoundingBox of all instances of <code>YaegerEntity</code> that implement either <code>Collider</code> or <code>Collided</code>.</td></tr>
<tr><td style="text-align: left">--showDebug</td><td style="text-align: left">Show a debug window with information about the Scene. More information on the debug window can be found <a href="debugging.html">here</a>.</td></tr>
<tr><td style="text-align: left">--showGrid</td><td style="text-align: left">Show a coordinate grid as an overlay on each Scene. This can be useful when figuring out where exactly Entities are on the Scene.</td></tr>
<tr><td style="text-align: left">--enableScroll</td><td style="text-align: left">Enable the scrolling gesture for all instances of <code>ScrollableDynamicScene</code>. This can help during the development process of such a scene.</td></tr>
<tr><td style="text-align: left">--limitGWU</td><td style="text-align: left">Limit the Game World Update (GWU) to a max of 60/sec.</td></tr>
<tr><td style="text-align: left">--help</td><td style="text-align: left">Show this help screen with all commandline options.</td></tr>
</tbody></table>
</div>
<h2 id="using-command-line-arguments-from-an-ide"><a class="header" href="#using-command-line-arguments-from-an-ide">Using command line arguments from an IDE</a></h2>
<p>Since the command line arguments mainly focus on the development cycle, they
will likely only be used during development of a Yaeger Game. In such a case you
will be working in an IDE, which will also be responsible for creating a run
configuration. Part of such a run configuration will be the (extra) arguments
that can be passed to the application. So check the documentation of your IDE to
see where these arguments can be entered.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-a-game"><a class="header" href="#debugging-a-game">Debugging a game</a></h1>
<p>Yaeger provides a debugging dialog that shows information about the current
scene, and the machine it is running on. Since this dialog requires the
Game World Update to refresh itself, it gives little information on a scene that
extends <code>StaticScene</code>. But on a scene that extends <code>DynamicScene</code> it can give
insight.</p>
<p>To enable the debugging dialog, start you Yaeger game with the command line
argument as shown in <a href="commandline-arguments.html">Command line arguments</a>.</p>
<h2 id="processors-and-memory"><a class="header" href="#processors-and-memory">Processors and memory</a></h2>
<p>When run, a Java-program allocates memory through the JVM, the Java Virtual
Machine, which is part of the Java Runtime Environment (JRE). Depending on the
number of Objects that make up the program, it then uses this memory. Since,
during the lifecycle of a program, more and more Objects are created, you can
see the <em>total used memory</em> increase. When some of these Objects are no longer
used by the program, the memory they use gets cleared by the JVM. Hence, the
<em>total used memory</em> periodically decreases.</p>
<p>If the <em>total used memory</em> reaches the value of <em>total allocated memory</em>, the
program will come to a grinding halt.</p>
<h2 id="entities-suppliers-and-garbage"><a class="header" href="#entities-suppliers-and-garbage">Entities, suppliers and garbage</a></h2>
<p>The debugger keeps track of the number of Entities that are present on the
scene.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Entity</th><th style="text-align: left">Explanation</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>Dynamic Entities</strong></td><td style="text-align: left">Number of entities that extend <code>DynamicEntity</code></td></tr>
<tr><td style="text-align: left"><strong>Static Entities</strong></td><td style="text-align: left">Number of  entities that extend <code>StaticEntity</code></td></tr>
<tr><td style="text-align: left"><strong>Suppliers</strong></td><td style="text-align: left">Number of objects that are able to supply entities to the scene. This means all instances of <code>EntitySpawner</code>, but also the Scene itself.</td></tr>
<tr><td style="text-align: left"><strong>Garbage</strong></td><td style="text-align: left">Number of Entities that have been marked as garbage, by calling the <code>remove()</code> method. The will be removed from the Scene during the next Game World Update, which should result in a drop of <em>total used memory</em></td></tr>
<tr><td style="text-align: left"><strong>Key listening entities</strong></td><td style="text-align: left">Number of entities that implement <code>KeyListener</code></td></tr>
</tbody></table>
</div>
<h2 id="loaded-files"><a class="header" href="#loaded-files">Loaded files</a></h2>
<p>Image and audio files will probably make up most of Yaeger's memory usage. To
minimize this memory footprint, Yaeger reuses images if possible. Meaning,
for entities that use the same image file, this image file gets loaded only
once. The same goes for audio files. Because Yaeger tries to reclaim the
memory if such a file is no longer used, the background audio does get added to
the value in the debugger. As soon as it starts playing, Yaeger loses its
reference to the loaded file, and it continues playing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<p>This chapter will sum up known issues and solutions on how to bypass them. The
list is likely not complete, so do feel free to share your findings.</p>
<p>Some of the issues noted here can be seen as bugs, but that does not mean they
are easily resolved.</p>
<h2 id="my-mp3-file-is-not-being-played"><a class="header" href="#my-mp3-file-is-not-being-played">My MP3 file is not being played</a></h2>
<p>For some reason, not all MP3 files are supported. If playing an MP3 file does
not give any exceptions, but you can not hear it in game, it might be because
the MP3 file is not supported. To correct this, use
<a href="https://online-audio-converter.com/">a tool</a> to create an MP3 file that is
supported.</p>
<h2 id="an-entity-behaves-strangely-when-colliding"><a class="header" href="#an-entity-behaves-strangely-when-colliding">An entity behaves strangely when colliding</a></h2>
<p>Sometimes an entity behaves unexpected when colliding. For instance, it is set
to change its direction on collision, but when this happens it doesn't
immediately do so. First it seems to stutter a few times, after which it
finally behaves as expected.</p>
<p>This behaviour likely follows from the fact that the bounding box is used for
collision detection, and the bounding box is usually larger that the entity we
can see. Especially if the entity is a <code>SpriteEntity</code> containing a round image,
the bounding box is still rectangular. When this <code>SpriteEntity</code> is also
rotating, it is not unlikely that the angles of the rectangular bounding box
will again cause a collision on the Game World Update after the first collision.
Because of the second collision the entity will again change its direction
and this cycle can repeat itself until the entity no longer collides.</p>
<p>A workaround could be to use a <code>CompositeEntity</code> with a smaller hit box.</p>
<h2 id="i-use-tile-maps-timers-and-entities-on-the-same-scene-why-not-add-everything-in-the-setupentities-method"><a class="header" href="#i-use-tile-maps-timers-and-entities-on-the-same-scene-why-not-add-everything-in-the-setupentities-method">I use tile maps, timers and entities on the same scene, why not add everything in the <code>setupEntities()</code> method?</a></h2>
<p>Each <code>YaegerScene</code> exposes the method <code>setupEntities()</code>, which should be used
to add instances of <code>YaegerEntity</code> to the scene. When tile maps are required,
the scene should implement the interface <code>TileMapContainer</code>, after which
the method <code>setupTileMaps()</code> gets exposed and the method <code>addTileMap(TileMap)</code>
becomes available. The same goes for timers through the interface
<code>TimerContainer</code>.</p>
<p>In a Scene where either tileMaps or timers are required, it is very well
possible to ignore the <code>setupTileMaps()</code> or <code>setupTimers()</code> methods and add
TileMaps or Timers from the <code>setupEntities()</code> method. It is however preferable
to use the appropriate method, to maximize readability. Scenes can grow rather
large and to find specific entities, tile maps or timers, it can help to
group them within their specific methods.</p>
<h2 id="i-have-a-machine-with-apple-silicon-m1-m2-m3-etc"><a class="header" href="#i-have-a-machine-with-apple-silicon-m1-m2-m3-etc">I have a machine with Apple Silicon (M1, M2, M3, etc.)</a></h2>
<p>If you have a machine with Apple Silicon you might come across an error in the build process like this:</p>
<p><img src="images/00-mac-error.png" alt="Error building because of libraries that cannot be linked" /></p>
<p>To solve this you have to change the architecture of your JDK to one that is not specific to an ARM CPU.</p>
<p>Go to Project Structure, through File-&gt;Project Structure or enter the keycombo: <code>⌘+;</code>.</p>
<p>You will see something similar to this:</p>
<p><img src="./images/01-mac-project-structure.png" alt="Project Structure window in IntelliJ" /></p>
<p>Click on Edit next to the SDK overview and then choose <code>Download JDK</code>.</p>
<p><img src="./images/02-mac-download-jdk.png" alt="Download button" /></p>
<p>Then choose a JDK that does not have the descriptor: <code>aarch64</code>.</p>
<p><img src="./images/03-mac-without-aarch64.png" alt="JDK without aarch64" /></p>
<p>To finish click download.</p>
<p><img src="./images/04-mac-download.png" alt="Download the JDK" /></p>
<p>You should be able to build and run your project now.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
